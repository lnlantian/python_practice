shell是用户和Linux操作系统之间的接口。Linux中有多种shell，其中缺省使用的是Bash。本章讲述了shell的工作原理，shell的种类，shell的一般操作及Bash的特性。 　　shell是用户和Linux操作系统之间的接口。Linux中有多种shell，其中缺省使用的是Bash。本章讲述了shell的工作原理，shell的种类，shell的一般操作及Bash的特性。 
　　什么是shell 
　　Linux系统的shell作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言、命令解释程序及程序设计语言的统称。 
　　shell是用户和Linux内核之间的接口程序，如果把Linux内核想象成一个球体的中心，shell就是围绕内核的外层。当从shell或其他程序向Linux传递命令时，内核会做出相应的反应。 
　　shell是一个命令语言解释器，它拥有自己内建的shell命令集，shell也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由shell先解释然后传给Linux核心。 
　　有一些命令，比如改变工作目录命令cd，是包含在shell内部的。还有一些命令，例如拷贝命令cp和移动命令rm，是存在于文件系统中某个目录下的单独的程序。对用户而言，不必关心一个命令是建立在shell内部还是一个单独的程序。 
　　shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。
　
　　shell的另一个重要特性是它自身就是一个解释型的程序设计语言，shell程序设计语言支持绝大多数在高级语言中能见到的程序元素，如函数、变量、数组和程序控制结构。shell编程语言简单易学，任何在提示符中能键入的命令都能放到一个可执行的shell程序中。 
　　当普通用户成功登录，系统将执行一个称为shell的程序。正是shell进程提供了命令行提示符。作为默认值（TurboLinux系统默认的shell是BASH），对普通用户用“$”作提示符，对超级用户（root）用“#”作提示符。 
　　一旦出现了shell提示符，就可以键入命令名称及命令所需要的参数。shell将执行这些命令。如果一条命令花费了很长的时间来运行，或者在屏幕上产生了大量的输出，可以从键盘上按ctrl+c发出中断信号来中断它（在正常结束之前，中止它的执行）。 
　　当用户准备结束登录对话进程时，可以键入logout命令、exit命令或文件结束符（EOF）（按ctrl+d实现），结束登录。 
　　我们来实习一下shell是如何工作的。 
　　$ make work 
　　make:***No rule to make target ‘work’. Stop. 
　　$ 
　　注释：make是系统中一个命令的名字，后面跟着命令参数。在接收到这个命令后，shell便执行它。本例中，由于输入的命令参数不正确，系统返回信息后停止该命令的执行。 
　　在例子中，shell会寻找名为make的程序，并以work为参数执行它。make是一个经常被用来编译大程序的程序，它以参数作为目标来进行编译。在 “make work”中，make编译的目标是work。因为make找不到以work为名字的目标，它便给出错误信息表示运行失败，用户又回到系统提示符下。 
　　另外，用户键入有关命令行后，如果shell找不到以其中的命令名为名字的程序，就会给出错误信息。例如，如果用户键入： 
　　$ myprog 
　　bash:myprog:command not found 
　　$ 
　　可以看到，用户得到了一个没有找到该命令的错误信息。用户敲错命令后，系统一般会给出这样的错误信息。 
　　shell的种类 
　　Linux中的shell有多种类型，其中最常用的几种是Bourne shell（sh）、C shell（csh）和Korn shell（ksh）。三种shell各有优缺点。Bourne shell是UNIX最初使用的shell，并且在每种UNIX上都可以使用。Bourne shell在shell编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux操作系统缺省的shell是Bourne Again shell，它是Bourne shell的扩展，简称Bash，与Bourne shell完全向后兼容，并且在Bourne shell的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多C shell和Korn shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。 
　　C shell是一种比Bourne shell更适于编程的shell，它的语法与C语言很相似。 Linux为喜欢使用C shell的人提供了Tcsh。Tcsh是C shell的一个扩展版本。Tcsh包括命令行编辑、可编程单词补全、拼写校正、历史命令替换、作业控制和类似C语言的语法，它不仅和Bash shell是提示符兼容，而且还提供比Bash shell更多的提示符参数。 
　　Korn shell集合了C shell和Bourne shell的优点并且和Bourne shell完全兼容。Linux系统提供了pdksh（ksh的扩展），它支持任务控制，可以在命令行上挂起、后台执行、唤醒或终止程序。 
　　Linux并没有冷落其他shell用户，还包括了一些流行的shell如ash、zsh等。每个shell都有它的用途，有些shell是有专利的，有些能从Internet网上或其他来源获得。要决定使用哪个shell，只需读一下各种shell的联机帮助，并试用一下。 
　　用户在登录到Linux时由/etc/passwd文件来决定要使用哪个shell。例如： 
　　# fgrep lisa /etc/passwd 
　　lisa:x:500:500:TurboLinux User:/home/lisa:/bin/bash 
　　shell被列每行的末尾（/bin/bash）。 
　　由于Bash是Linux上缺省的shell，本章主要介绍Bash及其相关知识。 
　　shell命令 
　　命令行c 
　　用户登录到Linux系统时，可以看到一个shell提示符，标识了命令行的开始。用户可以在提示符后面输入任何命令及参数。例如： 
　　$ date 
　　二 11 23 01:34:58 CST 1999 
　　$ 
　　用户登录时，实际进入了shell，它遵循一定的语法将输入的命令加以解释并传给系统。命令行中输入的第一个字必须是一个命令的名字，第二个字是命令的选项或参数，命令行中的每个字必须由空格或TAB隔开，格式如下： 
　　$ Command Option Arguments 
　　1. 选项和参数 
　　选项是包括一个或多个字母的代码，它前面有一个减号（减号是必要的，Linux用它来区别选项和参数），选项可用于改变命令执行的动作的类型。例如： 
　　$ ls 
　　motd passwd 
　　$ 
　　这是没有选项的ls命令，可列出当前目录中所有文件，只列出各个文件的名字，而不显示其他更多的信息。 
　　$ ls -l 
　　total 2 
　　-rw-r--r-- 2 wzh book 22 Apr 20 20:37 motd 
　　-rw-r--r-- 2 wzh book 796 Apr 20 20:37 passwd 
　　$ 
　　加入-l选项，将会为每个文件列出一行信息，诸如数据大小和数据最后被修改的时间。 
　　大多数命令都被设计为可以接纳参数。参数是在命令行中的选项之后键入的一个或多个单词，例如： 
　　$ ls -l text 
　　-rw-r--r-- 2 wzh book 22 Apr 20 20:37 motd 
　　-rw-r--r-- 2 wzh book 796 Apr 20 20:37 passwd 
　　$ 
　　将显示text目录下的所有文件及其信息。 
　　有些命令，如ls可以带参数，而有一些命令可能需要一些最小数目的参数。例如，cp命令至少需要两个参数，如果参数的数目与命令要求不符，shell将会给出出错信息。例如： 
　　$ cp -i mydata newdata 
　　注意：命令行中选项先于参数输入。 
　　2. 命令行特征 
　　命令行实际上是可以编辑的一个文本缓冲区，在按回车之前，可以对输入的文本进行编辑。比如利用BACKSPACE键可以删除刚键入的字符，可以进行整行删除，还可以插入字符，使得用户在输入命令，尤其是复杂命令时，若出现键入错误，无须重新输入整个命令，只要利用编辑操作，即可改正错误。 
　　利用上箭头可以重新显示刚执行的命令，利用这一功能可以重复执行以前执行过的命令，而无须重新键入该命令。 
　　bash保存着以前键入过的命令的列表，这一列表被称为命令历史表。按动上箭头，便可以在命令行上逐次显示各条命令。同样，按动下箭头可以在命令列表中向下移动，这样可以将以前的各条命令显示在命令行上，用户可以修改并执行这些命令。这一特征将在10.4节中进行详细的论述。 
　　在一个命令行中还可以置入多个命令，用分号将各个命令隔开。例如： 
　　$ ls -F;cp -i mydata newdata 
　　也可以在几个命令行中输入一个命令，用反斜杠将一个命令行持续到下一行。 
　　$ cp –i 
　　mydata 
　　newdata 
　　　 
　　上面的cp命令是在三行中输入的，开始的两行以反斜杠结束，把三行作为一个命令行。 
　　shell中的特殊字符 
　　shell中除使用普通字符外，还可以使用一些具有特殊含义和功能的特殊字符。在使用它们时应注意其特殊的含义和作用范围。下面分别对这些特殊字符加以介绍。 
　　1. 通配符 
　　通配符用于模式匹配，如文件名匹配、路经名搜索、字符串查找等。常用的通配符有*、?和括在方括号［ ］中的字符序列。用户可以在作为命令参数的文件名中包含这些通配符，构成一个所谓的“模式串”，在执行过程中进行模式匹配。 
　　* 代表任何字符串（长度可以不等），例如：“f*”匹配以f打头的任意字符串。但应注意，文件名前的圆点（.）和路经名中的斜线（/）必须显式匹配。例如“*”不能匹配.file，而“.*”才可以匹配.file。 
　　? 代表任何单个字符。 
　　［］ 代表指定的一个字符范围，只要文件名中［］位置处的字符在［］中指定的范围之内，那么这个文件名就与这个模式串匹配。方括号中的字符范围可以由直接给出的字符组成，也可以由表示限定范围的起始字符、终止字符及中间的连字符（-）组成。例如，f ［a- d］ 与f ［abcd］的作用相同。Shell将把与命令行中指定的模式串相匹配的所有文件名都作为命令的参数，形成最终的命令，然后再执行这个命令。 
　　下面我们给出表10-1说明这些通配符的具体含义。 
　　表10-1　通配符含义举例 
　　模式串 
　　意 义 
　　* 
　　当前目录下所有文件的名称。 
　　*Text* 
　　当前目录下所有文件名中包含有Text的文件的名称。 
　　［ab-dm］* 
　　当前目录下所有以a、b、c、d、m开头的文件的名称。 
　　［ab-dm］? 
　　当前目录下所有以a、b、c、d、m开头且后面只跟有一个字符的文件的名称。 
　　/usr/bin/?? 
　　目录/usr/bin下所有名称为两个字符的文件的名称。 
　　特别需要注意的是，连字符“-”仅在方括号内有效，表示字符范围，如在方括号外面就成为普通字符了。而*和?只在方括号外面是通配符，若出现在方括号之内，它们也失去通配符的能力，成为普通字符了。例如，模式“- a［*?］abc”中只有一对方括号是通配符，*和?均为普通字符，因此，它匹配的字符串只能是- a*abc和- a?abc。 
　　最后说明一下使用通配符时需要注意的一些问题。由于*、?和［］对于shell来说具有比较特殊的意义，因此在正常的文件名中不应出现这些字符。特别是在目录名中不要出现它们，否则Shell匹配起来可能会无穷的递归下去。另外要注意的一点是：如果目录中没有与指定的模式串相匹配的文件名，那么Shell 将使用此模式串本身作为参数传给有关命令。这可能就是命令中出现特殊字符的原因所在。 
　　2. 引号 
　　在shell中引号分为三种：单引号，双引号和反引号。 
　　* 单引号 ‘ 
　　由单引号括起来的字符都作为普通字符出现。特殊字符用单引号括起来以后，也会失去原有意义，而只作为普通字符解释。例如： 
　　$ string=’$PATH’ 
　　$ echo $string 
　　$PATH 
　　$ 
　　可见$保持了其本身的含义，作为普通字符出现。 
　　* 双引号 “ 
　　由双引号括起来的字符，除$、、’、和”这几个字符仍是特殊字符并保留其特殊功能外，其余字符仍作为普通字符对待。对于$来说，就是用其后指定的变量的值来代替这个变量和$；对于而言，是转义字符，它告诉shell不要对其后面的那个字符进行特殊处理，只当作普通字符即可。可以想见，在双引号中需要在前面加上的只有四个字符$，，’和”本身。而对”号，若其前面没有加，则Shell会将它同前一个”号匹配。 
　　例如，我们假定PATH的值为.:/usr/bin:/bin，输入如下命令： 
　　$ TestString＝”$PATH”$PATH” 
　　$ echo $TestString 
　　.:/usr/bin:/ bin”$PATH 
　　$ 
　　读者可以自己试一下在第二个双引号之前不加会产生什么结果。 
　　　 
　　* 反引号 ` 
　　反引号（`）这个字符所对应的键一般位于键盘的左上角，不要将其同单引号（’）混淆。反引号括起来的字符串被shell解释为命令行，在执行时，shell首先执行该命令行，并以它的标准输出结果取代整个反引号（包括两个反引号）部分。例如： 
　　$ pwd 
　　/home/xyz 
　　$ string=”current directory is `pwd`” 
　　$ echo $string 
　　current directour is /home/xyz 
　　$ 
　　shell执行echo命令时，首先执行`pwd`中的命令pwd，并将输出结果/home/xyz取代`pwd`这部分，最后输出替换后的整个结果。 
　　利用反引号的这种功能可以进行命令置换，即把反引号括起来的执行结果赋值给指定变量。例如： 
　　$ today=`date` 
　　$ echo Today is $today 
　　Today is Mon Apr 15 16:20:13 CST 1999 
　　$ 
　　反引号还可以嵌套使用。但需注意，嵌套使用时内层的反引号必须用反斜线（）将其转义。例如： 
　　$ abc=`echo The number of users is `who| wc-l`` 
　　$ echo $abc 
　　The number of users is 5 
　　$ 
　　在反引号之间的命令行中也可以使用shell的特殊字符。Shell为得到``中命令的结果，它实际上要去执行``中指定的命令。执行时，命令中的特殊字符，如$，”，?等又将具有特殊含义，并且``所包含的可以是任何一个合法的Shell命令，如： 
　　$ ls 
　　note readme.txt Notice Unix.dir 
　　$ TestString＝”`echo $HOME ` ` ls ［nN］*`” 
　　$ echo $TestString 
　　/home/yxz note Notice 
　　$ 
　　其他情况，读者可自行试之。 
　　1. 注释符 
　　在shell编程中经常要对某些正文行进行注释，以增加程序的可读性。在Shell中以字符“#”开头的正文行表示注释行。 
　　此外还有一些特殊字符如：用于输入/输出重定向与管道的、 >和|；执行后台命令的&amp;；命令执行操作符&amp;&amp;和||及表示命令组的{}将在下面各小节中加以介绍。 
　　 标准输入/输出和重定向 
　　1. 标准输入与输出 
　　我们知道，执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），通常对应终端的键盘；标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。 
　　我们以cat命令为例，cat命令的功能是从命令行给出的文件中读取数据，并将这些数据直接送到标准输出。若使用如下命令： 
　　$ cat config 
　　将会把文件config的内容依次显示到屏幕上。但是，如果cat的命令行中没有参数，它就会从标准输入中读取数据，并将其送到标准输出。例如： 
　　$ cat 
　　Hello world 
　　Hello world 
　　Bye 
　　Bye 
　　 
　　$ 
　　用户输入的每一行都立刻被cat命令输出到屏幕上。 
　　另一个例子，命令sort按行读入文件正文（当命令行中没有给出文件名时，表示从标准输入读入），将其排序，并将结果送到标准输出。下面的例子是从标准输入读入一个采购单，并将其排序。 
　　$ sort 
　　bananas 
　　carrots 
　　apples 
　　 
　　apples 
　　bananas 
　　carrots 
　　$ 
　　这时我们在屏幕上得到了已排序的采购单。 
　　直接使用标准输入/输出文件存在以下问题： 
　　输入数据从终端输入时，用户费了半天劲输入的数据只能用一次。下次再想用这些数据时就得重新输入。而且在终端上输入时，若输入有误修改起来不是很方便。 
　　输出到终端屏幕上的信息只能看不能动。我们无法对此输出作更多处理，如将输出作为另一命令的输入进行进一步的处理等。 
　　为了解决上述问题，Linux系统为输入、输出的传送引入了另外两种机制，即输入/输出重定向和管道。 
　　2. 输入重定向 
　　输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。所以说，输入重定向主要用于改变一个命令的输入源，特别是改变那些需要大量输入的输入源。 
　　例如，命令wc统计指定文件包含的行数、单词数和字符数。如果仅在命令行上键入： 
　　$ wc 
　　wc将等待用户告诉它统计什么，这时shell就好象死了一样，从键盘键入的所有文本都出现在屏幕上，但并没有什么结果，直至按下＜ctrl+d＞，wc才将命令结果写在屏幕上。 
　　如果给出一个文件名作为wc命令的参数，如下例所示，wc将返回该文件所包含的行数、单词数和字符数。 
　　$ wc /etc/passwd 
　　20 23 726 /etc/passwd 
　　$ 
　　另一种把/etc/passwd文件内容传给wc命令的方法是重定向wc的输入。输入重定向的一般形式为：命令this text forms the content 
　　>of the here document，which 
　　>continues until the end of 
　　>text delimter 
　　>delim 
　　4 17 98 
　　在文件名。例如： 
　　$ ls > directory.out 
　　$ cat directory.out 
　　ch1.doc ch2.doc ch3.doc chimp config mail/ test/ 
　　$ 
　　将ls命令的输出保存为一个名为directory.out的文件。 
　　注：如果>符号后边的文件已存在，那么这个文件将被重写。 
　　为避免输出重定向中指定文件只能存放当前命令的输出重定向的内容，shell提供了输出重定向的一种追加手段。输出追加重定向与输出重定向的功能非常相似，区别仅在于输出追加重定向的功能是把命令（或可执行程序）的输出结果追加到指定文件的最后，而该文件原有内容不被破坏。 
　　如果要将一条命令的输出结果追加到指定文件的后面，可以使用追加重定向操作符>>。形式为：命令>>文件名。例如： 
　　$ ls *.doc>>directory.out 
　　$ cat directory.out 
　　ch1.doc ch2.doc ch3.doc chimp config mail/ test/ 
　　ch1.doc ch2.doc ch3.doc 
　　$ 
　　和程序的标准输出重定向一样，程序的错误输出也可以重新定向。使用符号2>（或追加符号2>>）表示对错误输出设备重定向。例如下面的命令： 
　　$ ls /usr/tmp 2> err.file 
　　可在屏幕上看到程序的正常输出结果，但又将程序的任何错误信息送到文件err.file中，以备将来检查用。 
　　还可以使用另一个输出重定向操作符（&amp;>）将标准输出和错误输出同时送到同一文件中。例如： 
　　$ ls /usr/tmp &amp;> output.file 
　　利用重定向将命令组合在一起，可实现系统单个命令不能提供的新功能。例如使用下面的命令序列： 
　　$ ls /usr/bin > /tmp/dir 
　　$ wc –w 
